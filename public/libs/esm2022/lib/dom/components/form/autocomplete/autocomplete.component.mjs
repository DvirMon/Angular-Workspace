import { NgFor, NgIf, NgTemplateOutlet } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChild, EventEmitter, Input, Output, effect, input, } from '@angular/core';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { MatAutocompleteModule, } from '@angular/material/autocomplete';
import { MatOption } from '@angular/material/core';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { rxMethod } from '@ngrx/signals/rxjs-interop';
import { Subject, debounceTime, distinctUntilChanged, map, pipe, tap, } from 'rxjs';
// eslint-disable-next-line @nx/enforce-module-boundaries
import { OptionContentDirective } from '../../../directives';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "@angular/material/form-field";
import * as i3 from "@angular/material/input";
import * as i4 from "@angular/material/autocomplete";
import * as i5 from "@angular/material/core";
export class AutocompleteComponent {
    #valueChanged;
    constructor() {
        this.label = input('');
        this.defaultValue = input();
        this.options = input.required();
        this.control = input.required();
        this.optionTemplate = input();
        this.displayFn = () => '';
        this.queryChanged = new EventEmitter();
        this.optionSelected = new EventEmitter();
        this.#valueChanged = new Subject();
        this.onTermChanged = rxMethod(pipe(debounceTime(300), distinctUntilChanged(), map((value) => (!value ? this.defaultValue() : value)), tap((value) => this.queryChanged.emit(value))));
        effect(() => {
            if (this.control()) {
                this.onTermChanged(this.#valueChanged.asObservable());
            }
        }, { allowSignalWrites: true });
    }
    onOptionSelected(event) {
        const option = event.option.value;
        this.optionSelected.emit(option);
    }
    onInputChanged() {
        this.#valueChanged.next(this.control().value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.3.2", ngImport: i0, type: AutocompleteComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.0.0", version: "17.3.2", type: AutocompleteComponent, isStandalone: true, selector: "dom-autocomplete", inputs: { label: { classPropertyName: "label", publicName: "label", isSignal: true, isRequired: false, transformFunction: null }, defaultValue: { classPropertyName: "defaultValue", publicName: "defaultValue", isSignal: true, isRequired: false, transformFunction: null }, options: { classPropertyName: "options", publicName: "options", isSignal: true, isRequired: true, transformFunction: null }, control: { classPropertyName: "control", publicName: "control", isSignal: true, isRequired: true, transformFunction: null }, optionTemplate: { classPropertyName: "optionTemplate", publicName: "optionTemplate", isSignal: true, isRequired: false, transformFunction: null }, displayFn: { classPropertyName: "displayFn", publicName: "displayFn", isSignal: false, isRequired: false, transformFunction: null } }, outputs: { queryChanged: "queryChanged", optionSelected: "optionSelected" }, queries: [{ propertyName: "optionContentDirective", first: true, predicate: OptionContentDirective, descendants: true }], ngImport: i0, template: "<mat-form-field appearance=\"outline\">\n  @if(!!label()) {\n  <ng-container>\n    <mat-label>{{ label() }}</mat-label>\n  </ng-container>\n  }\n  <input\n    #input\n    type=\"text\"\n    matInput\n    autocomplete=\"off\"\n    [formControl]=\"control()\"\n    [matAutocomplete]=\"auto\"\n    (input)=\"onInputChanged()\"\n  />\n  <mat-autocomplete\n    (optionSelected)=\"onOptionSelected($event)\"\n    autoActiveFirstOption\n    [displayWith]=\"displayFn\"\n    #auto=\"matAutocomplete\"\n  >\n    <ng-container *ngFor=\"let option of options()\">\n      <mat-option [value]=\"option\">\n        <ng-container *ngIf=\"optionContentDirective; else defaultTemplate\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              optionContentDirective.template;\n              context: { $implicit: option }\n            \"\n          ></ng-container>\n        </ng-container>\n\n        <ng-template #defaultTemplate>\n          {{ option }}\n        </ng-template>\n      </mat-option>\n    </ng-container>\n  </mat-autocomplete>\n</mat-form-field>\n", styles: ["mat-form-field{width:100%}\n"], dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "ngmodule", type: FormsModule }, { kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "ngmodule", type: ReactiveFormsModule }, { kind: "directive", type: i1.FormControlDirective, selector: "[formControl]", inputs: ["formControl", "disabled", "ngModel"], outputs: ["ngModelChange"], exportAs: ["ngForm"] }, { kind: "ngmodule", type: MatFormFieldModule }, { kind: "component", type: i2.MatFormField, selector: "mat-form-field", inputs: ["hideRequiredMarker", "color", "floatLabel", "appearance", "subscriptSizing", "hintLabel"], exportAs: ["matFormField"] }, { kind: "directive", type: i2.MatLabel, selector: "mat-label" }, { kind: "ngmodule", type: MatInputModule }, { kind: "directive", type: i3.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { kind: "ngmodule", type: MatAutocompleteModule }, { kind: "component", type: i4.MatAutocomplete, selector: "mat-autocomplete", inputs: ["aria-label", "aria-labelledby", "displayWith", "autoActiveFirstOption", "autoSelectActiveOption", "requireSelection", "panelWidth", "disableRipple", "class", "hideSingleSelectionIndicator"], outputs: ["optionSelected", "opened", "closed", "optionActivated"], exportAs: ["matAutocomplete"] }, { kind: "component", type: i5.MatOption, selector: "mat-option", inputs: ["value", "id", "disabled"], outputs: ["onSelectionChange"], exportAs: ["matOption"] }, { kind: "directive", type: i4.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", inputs: ["matAutocomplete", "matAutocompletePosition", "matAutocompleteConnectedTo", "autocomplete", "matAutocompleteDisabled"], exportAs: ["matAutocompleteTrigger"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.3.2", ngImport: i0, type: AutocompleteComponent, decorators: [{
            type: Component,
            args: [{ selector: 'dom-autocomplete', standalone: true, imports: [
                        NgFor,
                        NgIf,
                        NgTemplateOutlet,
                        FormsModule,
                        ReactiveFormsModule,
                        MatFormFieldModule,
                        MatInputModule,
                        MatAutocompleteModule,
                        MatOption,
                        OptionContentDirective,
                    ], changeDetection: ChangeDetectionStrategy.OnPush, template: "<mat-form-field appearance=\"outline\">\n  @if(!!label()) {\n  <ng-container>\n    <mat-label>{{ label() }}</mat-label>\n  </ng-container>\n  }\n  <input\n    #input\n    type=\"text\"\n    matInput\n    autocomplete=\"off\"\n    [formControl]=\"control()\"\n    [matAutocomplete]=\"auto\"\n    (input)=\"onInputChanged()\"\n  />\n  <mat-autocomplete\n    (optionSelected)=\"onOptionSelected($event)\"\n    autoActiveFirstOption\n    [displayWith]=\"displayFn\"\n    #auto=\"matAutocomplete\"\n  >\n    <ng-container *ngFor=\"let option of options()\">\n      <mat-option [value]=\"option\">\n        <ng-container *ngIf=\"optionContentDirective; else defaultTemplate\">\n          <ng-container\n            *ngTemplateOutlet=\"\n              optionContentDirective.template;\n              context: { $implicit: option }\n            \"\n          ></ng-container>\n        </ng-container>\n\n        <ng-template #defaultTemplate>\n          {{ option }}\n        </ng-template>\n      </mat-option>\n    </ng-container>\n  </mat-autocomplete>\n</mat-form-field>\n", styles: ["mat-form-field{width:100%}\n"] }]
        }], ctorParameters: () => [], propDecorators: { optionContentDirective: [{
                type: ContentChild,
                args: [OptionContentDirective]
            }], displayFn: [{
                type: Input
            }], queryChanged: [{
                type: Output
            }], optionSelected: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2xpYnMvc3JjL2xpYi9kb20vY29tcG9uZW50cy9mb3JtL2F1dG9jb21wbGV0ZS9hdXRvY29tcGxldGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9zcmMvbGliL2RvbS9jb21wb25lbnRzL2Zvcm0vYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ2hFLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFFTixNQUFNLEVBQ04sS0FBSyxHQUNOLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBZSxXQUFXLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvRSxPQUFPLEVBQ0wscUJBQXFCLEdBRXRCLE1BQU0sZ0NBQWdDLENBQUM7QUFDeEMsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ25ELE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ2xFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDdEQsT0FBTyxFQUNMLE9BQU8sRUFDUCxZQUFZLEVBQ1osb0JBQW9CLEVBQ3BCLEdBQUcsRUFDSCxJQUFJLEVBQ0osR0FBRyxHQUNKLE1BQU0sTUFBTSxDQUFDO0FBQ2QseURBQXlEO0FBQ3pELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7Ozs7O0FBcUI3RCxNQUFNLE9BQU8scUJBQXFCO0lBZ0JoQyxhQUFhLENBQWtDO0lBVy9DO1FBMUJBLFVBQUssR0FBRyxLQUFLLENBQVMsRUFBRSxDQUFDLENBQUM7UUFDMUIsaUJBQVksR0FBRyxLQUFLLEVBQVUsQ0FBQztRQUMvQixZQUFPLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBTyxDQUFDO1FBQ2hDLFlBQU8sR0FBRyxLQUFLLENBQUMsUUFBUSxFQUF3QixDQUFDO1FBRWpELG1CQUFjLEdBQUcsS0FBSyxFQUF3QixDQUFDO1FBS3RDLGNBQVMsR0FBMEIsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDO1FBRTNDLGlCQUFZLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztRQUMxQyxtQkFBYyxHQUFHLElBQUksWUFBWSxFQUFLLENBQUM7UUFFakQsa0JBQWEsR0FBb0IsSUFBSSxPQUFPLEVBQUUsQ0FBQztRQUV2QyxrQkFBYSxHQUFHLFFBQVEsQ0FDOUIsSUFBSSxDQUNGLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFDakIsb0JBQW9CLEVBQUUsRUFDdEIsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQ3RELEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FDOUMsQ0FDRixDQUFDO1FBR0EsTUFBTSxDQUNKLEdBQUcsRUFBRTtZQUNILElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7Z0JBQ25CLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO1lBQ3hELENBQUM7UUFDSCxDQUFDLEVBQ0QsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsQ0FDNUIsQ0FBQztJQUNKLENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxLQUFtQztRQUNsRCxNQUFNLE1BQU0sR0FBTSxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUNyQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRUQsY0FBYztRQUNaLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxLQUFlLENBQUMsQ0FBQztJQUMxRCxDQUFDOzhHQTdDVSxxQkFBcUI7a0dBQXJCLHFCQUFxQixnL0JBUWxCLHNCQUFzQixnREMzRHRDLDhpQ0F1Q0Esc0ZESEksS0FBSyxtSEFDTCxJQUFJLDZGQUNKLGdCQUFnQixtSkFDaEIsV0FBVyxzWkFDWCxtQkFBbUIsaU5BQ25CLGtCQUFrQiwwU0FDbEIsY0FBYywwV0FDZCxxQkFBcUI7OzJGQVFaLHFCQUFxQjtrQkFuQmpDLFNBQVM7K0JBQ0Usa0JBQWtCLGNBQ2hCLElBQUksV0FDUDt3QkFDUCxLQUFLO3dCQUNMLElBQUk7d0JBQ0osZ0JBQWdCO3dCQUNoQixXQUFXO3dCQUNYLG1CQUFtQjt3QkFDbkIsa0JBQWtCO3dCQUNsQixjQUFjO3dCQUNkLHFCQUFxQjt3QkFDckIsU0FBUzt3QkFDVCxzQkFBc0I7cUJBQ3ZCLG1CQUdnQix1QkFBdUIsQ0FBQyxNQUFNO3dEQVcvQyxzQkFBc0I7c0JBRHJCLFlBQVk7dUJBQUMsc0JBQXNCO2dCQUczQixTQUFTO3NCQUFqQixLQUFLO2dCQUVJLFlBQVk7c0JBQXJCLE1BQU07Z0JBQ0csY0FBYztzQkFBdkIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5nRm9yLCBOZ0lmLCBOZ1RlbXBsYXRlT3V0bGV0IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZCxcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgT3V0cHV0LFxuICBUZW1wbGF0ZVJlZixcbiAgZWZmZWN0LFxuICBpbnB1dCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgRm9ybXNNb2R1bGUsIFJlYWN0aXZlRm9ybXNNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICBNYXRBdXRvY29tcGxldGVNb2R1bGUsXG4gIE1hdEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQsXG59IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2F1dG9jb21wbGV0ZSc7XG5pbXBvcnQgeyBNYXRPcHRpb24gfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IE1hdEZvcm1GaWVsZE1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2Zvcm0tZmllbGQnO1xuaW1wb3J0IHsgTWF0SW5wdXRNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9pbnB1dCc7XG5pbXBvcnQgeyByeE1ldGhvZCB9IGZyb20gJ0BuZ3J4L3NpZ25hbHMvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7XG4gIFN1YmplY3QsXG4gIGRlYm91bmNlVGltZSxcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIG1hcCxcbiAgcGlwZSxcbiAgdGFwLFxufSBmcm9tICdyeGpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAbngvZW5mb3JjZS1tb2R1bGUtYm91bmRhcmllc1xuaW1wb3J0IHsgT3B0aW9uQ29udGVudERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdkb20tYXV0b2NvbXBsZXRlJyxcbiAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgaW1wb3J0czogW1xuICAgIE5nRm9yLFxuICAgIE5nSWYsXG4gICAgTmdUZW1wbGF0ZU91dGxldCxcbiAgICBGb3Jtc01vZHVsZSxcbiAgICBSZWFjdGl2ZUZvcm1zTW9kdWxlLFxuICAgIE1hdEZvcm1GaWVsZE1vZHVsZSxcbiAgICBNYXRJbnB1dE1vZHVsZSxcbiAgICBNYXRBdXRvY29tcGxldGVNb2R1bGUsXG4gICAgTWF0T3B0aW9uLFxuICAgIE9wdGlvbkNvbnRlbnREaXJlY3RpdmUsXG4gIF0sXG4gIHRlbXBsYXRlVXJsOiAnLi9hdXRvY29tcGxldGUuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybDogJy4vYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5zY3NzJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIEF1dG9jb21wbGV0ZUNvbXBvbmVudDxUPiB7XG4gIGxhYmVsID0gaW5wdXQ8c3RyaW5nPignJyk7XG4gIGRlZmF1bHRWYWx1ZSA9IGlucHV0PHN0cmluZz4oKTtcbiAgb3B0aW9ucyA9IGlucHV0LnJlcXVpcmVkPFRbXT4oKTtcbiAgY29udHJvbCA9IGlucHV0LnJlcXVpcmVkPEZvcm1Db250cm9sPHVua25vd24+PigpO1xuXG4gIG9wdGlvblRlbXBsYXRlID0gaW5wdXQ8VGVtcGxhdGVSZWY8dW5rbm93bj4+KCk7XG5cbiAgQENvbnRlbnRDaGlsZChPcHRpb25Db250ZW50RGlyZWN0aXZlKVxuICBvcHRpb25Db250ZW50RGlyZWN0aXZlITogT3B0aW9uQ29udGVudERpcmVjdGl2ZTtcblxuICBASW5wdXQoKSBkaXNwbGF5Rm46IChvcHRpb246IFQpID0+IHN0cmluZyA9ICgpID0+ICcnO1xuXG4gIEBPdXRwdXQoKSBxdWVyeUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPHN0cmluZz4oKTtcbiAgQE91dHB1dCgpIG9wdGlvblNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcjxUPigpO1xuXG4gICN2YWx1ZUNoYW5nZWQ6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0KCk7XG5cbiAgcHJpdmF0ZSBvblRlcm1DaGFuZ2VkID0gcnhNZXRob2Q8c3RyaW5nPihcbiAgICBwaXBlKFxuICAgICAgZGVib3VuY2VUaW1lKDMwMCksXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgbWFwKCh2YWx1ZSkgPT4gKCF2YWx1ZSA/IHRoaXMuZGVmYXVsdFZhbHVlKCkgOiB2YWx1ZSkpLFxuICAgICAgdGFwKCh2YWx1ZSkgPT4gdGhpcy5xdWVyeUNoYW5nZWQuZW1pdCh2YWx1ZSkpXG4gICAgKVxuICApO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGVmZmVjdChcbiAgICAgICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbCgpKSB7XG4gICAgICAgICAgdGhpcy5vblRlcm1DaGFuZ2VkKHRoaXMuI3ZhbHVlQ2hhbmdlZC5hc09ic2VydmFibGUoKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IGFsbG93U2lnbmFsV3JpdGVzOiB0cnVlIH1cbiAgICApO1xuICB9XG5cbiAgb25PcHRpb25TZWxlY3RlZChldmVudDogTWF0QXV0b2NvbXBsZXRlU2VsZWN0ZWRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IG9wdGlvbjogVCA9IGV2ZW50Lm9wdGlvbi52YWx1ZTtcbiAgICB0aGlzLm9wdGlvblNlbGVjdGVkLmVtaXQob3B0aW9uKTtcbiAgfVxuXG4gIG9uSW5wdXRDaGFuZ2VkKCkge1xuICAgIHRoaXMuI3ZhbHVlQ2hhbmdlZC5uZXh0KHRoaXMuY29udHJvbCgpLnZhbHVlIGFzIHN0cmluZyk7XG4gIH1cbn1cbiIsIjxtYXQtZm9ybS1maWVsZCBhcHBlYXJhbmNlPVwib3V0bGluZVwiPlxuICBAaWYoISFsYWJlbCgpKSB7XG4gIDxuZy1jb250YWluZXI+XG4gICAgPG1hdC1sYWJlbD57eyBsYWJlbCgpIH19PC9tYXQtbGFiZWw+XG4gIDwvbmctY29udGFpbmVyPlxuICB9XG4gIDxpbnB1dFxuICAgICNpbnB1dFxuICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICBtYXRJbnB1dFxuICAgIGF1dG9jb21wbGV0ZT1cIm9mZlwiXG4gICAgW2Zvcm1Db250cm9sXT1cImNvbnRyb2woKVwiXG4gICAgW21hdEF1dG9jb21wbGV0ZV09XCJhdXRvXCJcbiAgICAoaW5wdXQpPVwib25JbnB1dENoYW5nZWQoKVwiXG4gIC8+XG4gIDxtYXQtYXV0b2NvbXBsZXRlXG4gICAgKG9wdGlvblNlbGVjdGVkKT1cIm9uT3B0aW9uU2VsZWN0ZWQoJGV2ZW50KVwiXG4gICAgYXV0b0FjdGl2ZUZpcnN0T3B0aW9uXG4gICAgW2Rpc3BsYXlXaXRoXT1cImRpc3BsYXlGblwiXG4gICAgI2F1dG89XCJtYXRBdXRvY29tcGxldGVcIlxuICA+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIG9wdGlvbnMoKVwiPlxuICAgICAgPG1hdC1vcHRpb24gW3ZhbHVlXT1cIm9wdGlvblwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwib3B0aW9uQ29udGVudERpcmVjdGl2ZTsgZWxzZSBkZWZhdWx0VGVtcGxhdGVcIj5cbiAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cIlxuICAgICAgICAgICAgICBvcHRpb25Db250ZW50RGlyZWN0aXZlLnRlbXBsYXRlO1xuICAgICAgICAgICAgICBjb250ZXh0OiB7ICRpbXBsaWNpdDogb3B0aW9uIH1cbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cblxuICAgICAgICA8bmctdGVtcGxhdGUgI2RlZmF1bHRUZW1wbGF0ZT5cbiAgICAgICAgICB7eyBvcHRpb24gfX1cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgPC9tYXQtYXV0b2NvbXBsZXRlPlxuPC9tYXQtZm9ybS1maWVsZD5cbiJdfQ==