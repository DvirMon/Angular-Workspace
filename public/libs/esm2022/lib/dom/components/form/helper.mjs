import { effect, runInInjectionContext, signal, } from '@angular/core';
import { rxMethod } from '@ngrx/signals/rxjs-interop';
import { debounceTime, distinctUntilChanged, map, pipe, startWith, tap, } from 'rxjs';
import { errorMessageMap } from './constants';
export function getFormKeys(obj) {
    return signal(Object.keys(obj.controls));
}
export function createValueChangesEmitter(valueChanged) {
    return rxMethod(pipe(debounceTime(300), distinctUntilChanged(), tap((value) => valueChanged(value))));
}
function setFormError(group, error) {
    if (group !== null && error !== null) {
        const control = group.get(error.control);
        if (control != null) {
            control.setErrors({ serverError: error.message });
        }
    }
}
/**
 * Applies an effect to handle server errors by updating a form's errors.
 *
 * @param injector An Angular Injector instance.
 * @param serverError A Signal representing the server error.
 * @param form The FormGroup instance to which the server error will be applied.
 * @returns void
 *
 * @remarks
 * This function sets up an effect to handle server errors by updating the errors
 * of a FormGroup instance. When a server error is emitted via the provided
 * `serverError` signal, this effect will update the form's errors
 * accordingly.
 *
 * Example usage:
 * ```typescript
 * handleServerErrorEffect(injector, serverErrorSignal, myFormGroup);
 * ```
 */
export function handleServerErrorEffect(injector, serverError, form) {
    effect(() => {
        const error = serverError();
        if (error) {
            setFormError(form, error);
        }
    }, { allowSignalWrites: true, injector });
}
export function getInputErrorMessage(errors, messages) {
    if (errors) {
        const errorKeys = Object.keys(errors);
        const errorMap = {
            ...errors,
            ...errorMessageMap,
            ...messages,
        };
        for (const error of errorKeys) {
            return errorMap[error];
        }
    }
    return '';
}
export function createErrorMessageEmitter(injector, messages, updater) {
    return runInInjectionContext(injector, () => {
        return rxMethod(pipe(map((errors) => getInputErrorMessage(errors, messages)), tap((value) => updater(value))));
    });
}
export function handleError(control, emitter) {
    const source$ = control.statusChanges.pipe(startWith(control.status), map(() => control.errors));
    emitter(source$);
}
export function withError() {
    return { handleError, createErrorMessageEmitter };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9zcmMvbGliL2RvbS9jb21wb25lbnRzL2Zvcm0vaGVscGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFJTCxNQUFNLEVBQ04scUJBQXFCLEVBQ3JCLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDdEQsT0FBTyxFQUVMLFlBQVksRUFDWixvQkFBb0IsRUFDcEIsR0FBRyxFQUNILElBQUksRUFDSixTQUFTLEVBQ1QsR0FBRyxHQUNKLE1BQU0sTUFBTSxDQUFDO0FBRWQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUU5QyxNQUFNLFVBQVUsV0FBVyxDQUFJLEdBQWM7SUFDM0MsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFnQixDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVELE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsWUFBcUM7SUFFckMsT0FBTyxRQUFRLENBQ2IsSUFBSSxDQUNGLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFDakIsb0JBQW9CLEVBQUUsRUFDdEIsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FDcEMsQ0FDRixDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsWUFBWSxDQUFDLEtBQWdCLEVBQUUsS0FBc0I7SUFDNUQsSUFBSSxLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUUsQ0FBQztRQUNyQyxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxPQUFpQixDQUFDLENBQUM7UUFFbkQsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFLENBQUM7WUFDcEIsT0FBTyxDQUFDLFNBQVMsQ0FBQyxFQUFFLFdBQVcsRUFBRSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztRQUNwRCxDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0gsTUFBTSxVQUFVLHVCQUF1QixDQUNyQyxRQUFrQixFQUNsQixXQUFnRCxFQUNoRCxJQUFlO0lBRWYsTUFBTSxDQUNKLEdBQUcsRUFBRTtRQUNILE1BQU0sS0FBSyxHQUFHLFdBQVcsRUFBRSxDQUFDO1FBRTVCLElBQUksS0FBSyxFQUFFLENBQUM7WUFDVixZQUFZLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzVCLENBQUM7SUFDSCxDQUFDLEVBQ0QsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsUUFBUSxFQUFFLENBQ3RDLENBQUM7QUFDSixDQUFDO0FBRUQsTUFBTSxVQUFVLG9CQUFvQixDQUNsQyxNQUF3QixFQUN4QixRQUFzQztJQUV0QyxJQUFJLE1BQU0sRUFBRSxDQUFDO1FBQ1gsTUFBTSxTQUFTLEdBQWEsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVoRCxNQUFNLFFBQVEsR0FBRztZQUNmLEdBQUcsTUFBTTtZQUNULEdBQUcsZUFBZTtZQUNsQixHQUFHLFFBQVE7U0FDWixDQUFDO1FBRUYsS0FBSyxNQUFNLEtBQUssSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUM5QixPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8sRUFBRSxDQUFDO0FBQ1osQ0FBQztBQUVELE1BQU0sVUFBVSx5QkFBeUIsQ0FDdkMsUUFBa0IsRUFDbEIsUUFBc0MsRUFDdEMsT0FBZ0M7SUFFaEMsT0FBTyxxQkFBcUIsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO1FBQzFDLE9BQU8sUUFBUSxDQUNiLElBQUksQ0FDRixHQUFHLENBQUMsQ0FBQyxNQUF3QixFQUFFLEVBQUUsQ0FDL0Isb0JBQW9CLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUN2QyxFQUNELEdBQUcsQ0FBQyxDQUFDLEtBQWEsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3ZDLENBQ0YsQ0FBQztJQUNKLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELE1BQU0sVUFBVSxXQUFXLENBQ3pCLE9BQW9CLEVBQ3BCLE9BQStEO0lBRS9ELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUN4QyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUN6QixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUMxQixDQUFDO0lBRUYsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25CLENBQUM7QUFFRCxNQUFNLFVBQVUsU0FBUztJQUN2QixPQUFPLEVBQUUsV0FBVyxFQUFFLHlCQUF5QixFQUFFLENBQUM7QUFDcEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEluamVjdG9yLFxuICBTaWduYWwsXG4gIFdyaXRhYmxlU2lnbmFsLFxuICBlZmZlY3QsXG4gIHJ1bkluSW5qZWN0aW9uQ29udGV4dCxcbiAgc2lnbmFsLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBGb3JtR3JvdXAsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyByeE1ldGhvZCB9IGZyb20gJ0BuZ3J4L3NpZ25hbHMvcnhqcy1pbnRlcm9wJztcbmltcG9ydCB7XG4gIE9ic2VydmFibGUsXG4gIGRlYm91bmNlVGltZSxcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIG1hcCxcbiAgcGlwZSxcbiAgc3RhcnRXaXRoLFxuICB0YXAsXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgRm9ybVNlcnZlckVycm9yIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgeyBlcnJvck1lc3NhZ2VNYXAgfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3JtS2V5czxUPihvYmo6IEZvcm1Hcm91cCk6IFdyaXRhYmxlU2lnbmFsPChrZXlvZiBUKVtdPiB7XG4gIHJldHVybiBzaWduYWwoT2JqZWN0LmtleXMob2JqLmNvbnRyb2xzKSBhcyAoa2V5b2YgVClbXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWYWx1ZUNoYW5nZXNFbWl0dGVyKFxuICB2YWx1ZUNoYW5nZWQ6ICh2YWx1ZTogc3RyaW5nKSA9PiB2b2lkXG4pIHtcbiAgcmV0dXJuIHJ4TWV0aG9kPHN0cmluZz4oXG4gICAgcGlwZShcbiAgICAgIGRlYm91bmNlVGltZSgzMDApLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIHRhcCgodmFsdWUpID0+IHZhbHVlQ2hhbmdlZCh2YWx1ZSkpXG4gICAgKVxuICApO1xufVxuXG5mdW5jdGlvbiBzZXRGb3JtRXJyb3IoZ3JvdXA6IEZvcm1Hcm91cCwgZXJyb3I6IEZvcm1TZXJ2ZXJFcnJvcik6IHZvaWQge1xuICBpZiAoZ3JvdXAgIT09IG51bGwgJiYgZXJyb3IgIT09IG51bGwpIHtcbiAgICBjb25zdCBjb250cm9sID0gZ3JvdXAuZ2V0KGVycm9yLmNvbnRyb2wgYXMgc3RyaW5nKTtcblxuICAgIGlmIChjb250cm9sICE9IG51bGwpIHtcbiAgICAgIGNvbnRyb2wuc2V0RXJyb3JzKHsgc2VydmVyRXJyb3I6IGVycm9yLm1lc3NhZ2UgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXBwbGllcyBhbiBlZmZlY3QgdG8gaGFuZGxlIHNlcnZlciBlcnJvcnMgYnkgdXBkYXRpbmcgYSBmb3JtJ3MgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSBpbmplY3RvciBBbiBBbmd1bGFyIEluamVjdG9yIGluc3RhbmNlLlxuICogQHBhcmFtIHNlcnZlckVycm9yIEEgU2lnbmFsIHJlcHJlc2VudGluZyB0aGUgc2VydmVyIGVycm9yLlxuICogQHBhcmFtIGZvcm0gVGhlIEZvcm1Hcm91cCBpbnN0YW5jZSB0byB3aGljaCB0aGUgc2VydmVyIGVycm9yIHdpbGwgYmUgYXBwbGllZC5cbiAqIEByZXR1cm5zIHZvaWRcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBzZXRzIHVwIGFuIGVmZmVjdCB0byBoYW5kbGUgc2VydmVyIGVycm9ycyBieSB1cGRhdGluZyB0aGUgZXJyb3JzXG4gKiBvZiBhIEZvcm1Hcm91cCBpbnN0YW5jZS4gV2hlbiBhIHNlcnZlciBlcnJvciBpcyBlbWl0dGVkIHZpYSB0aGUgcHJvdmlkZWRcbiAqIGBzZXJ2ZXJFcnJvcmAgc2lnbmFsLCB0aGlzIGVmZmVjdCB3aWxsIHVwZGF0ZSB0aGUgZm9ybSdzIGVycm9yc1xuICogYWNjb3JkaW5nbHkuXG4gKlxuICogRXhhbXBsZSB1c2FnZTpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGhhbmRsZVNlcnZlckVycm9yRWZmZWN0KGluamVjdG9yLCBzZXJ2ZXJFcnJvclNpZ25hbCwgbXlGb3JtR3JvdXApO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVTZXJ2ZXJFcnJvckVmZmVjdChcbiAgaW5qZWN0b3I6IEluamVjdG9yLFxuICBzZXJ2ZXJFcnJvcjogU2lnbmFsPEZvcm1TZXJ2ZXJFcnJvciB8IHVuZGVmaW5lZD4sXG4gIGZvcm06IEZvcm1Hcm91cFxuKTogdm9pZCB7XG4gIGVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvciA9IHNlcnZlckVycm9yKCk7XG5cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBzZXRGb3JtRXJyb3IoZm9ybSwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgeyBhbGxvd1NpZ25hbFdyaXRlczogdHJ1ZSwgaW5qZWN0b3IgfVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5wdXRFcnJvck1lc3NhZ2UoXG4gIGVycm9yczogVmFsaWRhdGlvbkVycm9ycyxcbiAgbWVzc2FnZXM6IFZhbGlkYXRpb25FcnJvcnMgfCB1bmRlZmluZWRcbik6IHN0cmluZyB7XG4gIGlmIChlcnJvcnMpIHtcbiAgICBjb25zdCBlcnJvcktleXM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXMoZXJyb3JzKTtcblxuICAgIGNvbnN0IGVycm9yTWFwID0ge1xuICAgICAgLi4uZXJyb3JzLFxuICAgICAgLi4uZXJyb3JNZXNzYWdlTWFwLFxuICAgICAgLi4ubWVzc2FnZXMsXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgZXJyb3Igb2YgZXJyb3JLZXlzKSB7XG4gICAgICByZXR1cm4gZXJyb3JNYXBbZXJyb3JdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVycm9yTWVzc2FnZUVtaXR0ZXIoXG4gIGluamVjdG9yOiBJbmplY3RvcixcbiAgbWVzc2FnZXM6IFZhbGlkYXRpb25FcnJvcnMgfCB1bmRlZmluZWQsXG4gIHVwZGF0ZXI6ICh2YWx1ZTogc3RyaW5nKSA9PiB2b2lkXG4pOiAoc291cmNlJDogT2JzZXJ2YWJsZTxWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbD4pID0+IHZvaWQge1xuICByZXR1cm4gcnVuSW5JbmplY3Rpb25Db250ZXh0KGluamVjdG9yLCAoKSA9PiB7XG4gICAgcmV0dXJuIHJ4TWV0aG9kPFZhbGlkYXRpb25FcnJvcnM+KFxuICAgICAgcGlwZShcbiAgICAgICAgbWFwKChlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMpID0+XG4gICAgICAgICAgZ2V0SW5wdXRFcnJvck1lc3NhZ2UoZXJyb3JzLCBtZXNzYWdlcylcbiAgICAgICAgKSxcbiAgICAgICAgdGFwKCh2YWx1ZTogc3RyaW5nKSA9PiB1cGRhdGVyKHZhbHVlKSlcbiAgICAgIClcbiAgICApO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUVycm9yKFxuICBjb250cm9sOiBGb3JtQ29udHJvbCxcbiAgZW1pdHRlcjogKHNvdXJjZSQ6IE9ic2VydmFibGU8VmFsaWRhdGlvbkVycm9ycyB8IG51bGw+KSA9PiB2b2lkXG4pIHtcbiAgY29uc3Qgc291cmNlJCA9IGNvbnRyb2wuc3RhdHVzQ2hhbmdlcy5waXBlKFxuICAgIHN0YXJ0V2l0aChjb250cm9sLnN0YXR1cyksXG4gICAgbWFwKCgpID0+IGNvbnRyb2wuZXJyb3JzKVxuICApO1xuXG4gIGVtaXR0ZXIoc291cmNlJCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoRXJyb3IoKSB7XG4gIHJldHVybiB7IGhhbmRsZUVycm9yLCBjcmVhdGVFcnJvck1lc3NhZ2VFbWl0dGVyIH07XG59XG4iXX0=